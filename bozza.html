<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>Sun Synth – Solar Wind Realtime Charts</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

<style>
    .space-mono-regular {
    font-family: "Space Mono", monospace;
    font-weight: 400;
    font-style: normal;
    }

    .space-mono-bold {
    font-family: "Space Mono", monospace;
    font-weight: 700;
    font-style: normal;
    }

    .space-mono-regular-italic {
    font-family: "Space Mono", monospace;
    font-weight: 400;
    font-style: italic;
    }

    .space-mono-bold-italic {
    font-family: "Space Mono", monospace;
    font-weight: 700;
    font-style: italic;
    }

    body {
        margin: 0;
        padding: 0;
        background: #FDFFFC;
        font-family: Arial;
    }

    .main-box {
        width: 95%;
        margin: 20px auto;
        border: 6px solid #FF9F1C;
        padding: 20px;
        border-radius: 10px;
    }

    .top-charts {
        display: flex;
        gap: 20px;
    }

    .chart-box {
        flex: 1;
        border: 4px solid #011627;
        border-radius: 6px;
        padding: 10px;
        background: #FDFFFC;
    }

    .chart-label {
        text-align: center;
        font-weight: bold;
        margin-top: 8px;
        font-size: 18px;
        font-family: "Space Mono", monospace;
        font-weight: 700;
        font-style: normal;
        color: #011627;
    }

    canvas {
        width: 100% !important;
        height: 160px !important;
    }
    /* Controls per l'evidenziazione */
    .controls {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 12px;
    }
    .controls label { font-weight: bold; }
    .controls input[type="range"] { width: 220px; }
</style>
</head>

<body>

<div class="main-box">

    <div class="controls">
        <label for="speedKnob">Velocità highlight:</label>
        <input id="speedKnob" type="range" min="50" max="2000" step="10" value="500">
        <span id="speedValue">500 ms</span>
        <button id="playPauseBtn">Play</button>
    </div>

    <div class="top-charts">

        <div class="chart-box">
            <canvas id="chartTemp"></canvas>
            <div class="chart-label">TEMPERATURA</div>
        </div>

        <div class="chart-box">
            <canvas id="chartDens"></canvas>
            <div class="chart-label">DENSITÀ</div>
        </div>

        <div class="chart-box">
            <canvas id="chartVel"></canvas>
            <div class="chart-label">VELOCITÀ</div>
        </div>

    </div>

</div>

<script>
/* ============================================================
   1) FUNZIONE PER INTERPOLAZIONE
============================================================ */
function interpolateLinear(xs, ys, newXs) {
    const out = [];
    let j = 0;

    for (let i = 0; i < newXs.length; i++) {
        const x = newXs[i];

        while (j < xs.length - 2 && x > xs[j+1]) j++;

        const x0 = xs[j];
        const x1 = xs[j+1];
        const y0 = ys[j];
        const y1 = ys[j+1];

        if (!Number.isFinite(y0) || !Number.isFinite(y1)) {
            out.push(null);
            continue;
        }

        const t = (x - x0) / (x1 - x0);
        out.push(y0 + t * (y1 - y0));
    }
    return out;
}

/* ============================================================
   2) CREA GRAFICO CON ASSI E TOOLTIPS VISIBILI
============================================================ */
function createChart(canvasId, color) {
    return new Chart(document.getElementById(canvasId), {
        type: "line",
        data: {
            datasets: [{
                data: [],
                parsing: false,
                borderColor: color,
                borderWidth: 2.5,
                // pointRadius and pointBackgroundColor are scriptable so
                // the highlighted index (global `highlightIndex`) can show a marker
                // reduced radius for a smaller dot
                pointRadius: (ctx) => (typeof highlightIndex === "number" && ctx.dataIndex === highlightIndex ? 3 : 0),
                pointBackgroundColor: (ctx) => (typeof highlightIndex === "number" && ctx.dataIndex === highlightIndex ? color : "rgba(0,0,0,0)"),
                pointBorderColor: color,
                tension: 0.25,
                spanGaps: false
            }]
        },
        options: {
            animation: false,

            scales: {
                x: {
                    type: "time",
                    time: {
                        tooltipFormat: "yyyy-MM-dd HH:mm",
                        displayFormats: {
                            hour: "HH:mm",
                            minute: "HH:mm"
                        }
                    },
                    ticks: {
                        maxTicksLimit: 5,
                        font: { size: 11 }
                    },
                    grid: { color: "#ddd" }
                },

                y: {
                    ticks: {
                        font: { size: 11 }
                    },
                    grid: { color: "#eee" }
                }
            },

            plugins: {
                legend: { display: false },

                tooltip: {
                    enabled: true,
                    mode: "nearest",
                    intersect: false,
                    callbacks: {
                        label: (ctx) =>
                            `${ctx.dataset.label || ""}: ${ctx.parsed.y.toFixed(2)}`
                    }
                }
            }
        }
    });
}

/* ============================================================
   3) CREA I 3 GRAFICI
============================================================ */
// Stato globale per l'evidenziazione: dichiarato prima della creazione dei grafici
let highlightIndex = -1;
let highlightTimer = null;
let highlightSpeed = 500; // ms di default

const chartTemp = createChart("chartTemp", "red");
const chartDens = createChart("chartDens", "orange");
const chartVel  = createChart("chartVel",  "green");

chartTemp.data.datasets[0].label = "Temperatura";
chartDens.data.datasets[0].label = "Densità";
chartVel.data.datasets[0].label  = "Velocità";

/* ============================================================
   4) FETCH + INTERPOLAZIONE + UPDATE
============================================================ */
async function updateCharts() {
    try {
        const url = "https://services.swpc.noaa.gov/products/solar-wind/plasma-1-day.json";
        const raw = await (await fetch(url, { cache: "no-store" })).json();

        if (typeof raw[0][0] === "string") raw.shift();

        const pts = raw.map(r => ({
            t: new Date(r[0]),
            dens: Number(r[1]),
            vel:  Number(r[2]),
            temp: Number(r[3])
        })).filter(p => !isNaN(p.t));

        pts.sort((a,b) => a.t - b.t);

        const xs   = pts.map(p => p.t.getTime());
        const dens = pts.map(p => p.dens);
        const vel  = pts.map(p => p.vel);
        const temp = pts.map(p => p.temp);

        // Interpolazione su 300 punti
        const NUM = 300;
        const minX = xs[0];
        const maxX = xs[xs.length - 1];
        const newXs = Array.from({length: NUM}, (_, i) =>
            minX + (i / (NUM - 1)) * (maxX - minX)
        );

        const tempInterp = interpolateLinear(xs, temp, newXs);
        const densInterp = interpolateLinear(xs, dens, newXs);
        const velInterp  = interpolateLinear(xs, vel,  newXs);

        chartTemp.data.datasets[0].data = newXs.map((x, i) => ({ x, y: tempInterp[i] }));
        chartDens.data.datasets[0].data = newXs.map((x, i) => ({ x, y: densInterp[i] }));
        chartVel.data.datasets[0].data  = newXs.map((x, i) => ({ x, y: velInterp[i] }));

        chartTemp.update("none");
        chartDens.update("none");
        chartVel.update("none");

    } catch (e) {
        console.error("Errore fetching NOAA:", e);
    }
}


/* ============================================================
   5) AVVIO + AGGIORNA OGNI 60 SECONDI
============================================================ */
// ---------- Highlighting: stato e controlli ----------
// `highlightIndex` indica l'indice corrente evidenziato (o -1 nessuno)
    // `highlightIndex` indica l'indice corrente evidenziato (o -1 nessuno)

function isValidDataAt(chart, idx) {
    const d = chart.data.datasets[0].data[idx];
    return d && Number.isFinite(d.y);
}

function updateHighlightRender() {
    chartTemp.update("none");
    chartDens.update("none");
    chartVel.update("none");
}

function advanceHighlight() {
    const len = chartTemp.data.datasets[0].data.length;
    if (!len) return;

    let next = highlightIndex;
    for (let i = 0; i < len; i++) {
        next = (next + 1) % len;
        if (isValidDataAt(chartTemp, next) || isValidDataAt(chartDens, next) || isValidDataAt(chartVel, next)) {
            highlightIndex = next;
            console.log("Temp: ", chartTemp.data.datasets[0].data[highlightIndex].y);
            updateHighlightRender();
            return;
        }
    }

    // nessun punto valido trovato
    highlightIndex = -1;
    updateHighlightRender();
}

 
function startHighlighting(speedMs = 500) {
    highlightSpeed = speedMs;
    if (highlightTimer !== null) clearInterval(highlightTimer);

    // se i dati non sono ancora pronti, aspetta un po' e poi avvia
    if (!chartTemp.data.datasets[0].data.length) {
        highlightIndex = -1;
        highlightTimer = setInterval(() => {
            if (chartTemp.data.datasets[0].data.length) {
                clearInterval(highlightTimer);
                highlightTimer = setInterval(advanceHighlight, highlightSpeed);
            }
        }, 200);
        return;
    }

    highlightIndex = -1; // iniziare prima del primo
    highlightTimer = setInterval(advanceHighlight, highlightSpeed);
    advanceHighlight(); // mostra subito il primo
}

function stopHighlighting() {
    if (highlightTimer) { clearInterval(highlightTimer); highlightTimer = null; }
    highlightIndex = -1;
    updateHighlightRender();
}

function setHighlightSpeed(ms) {
    const wasRunning = !!highlightTimer;
    stopHighlighting();
    highlightSpeed = ms;
    if (wasRunning) startHighlighting(ms/10);
}

// Wiring dei controlli UI (slider + play/pause)
const speedKnob = document.getElementById('speedKnob');
const speedValue = document.getElementById('speedValue');
const playPauseBtn = document.getElementById('playPauseBtn');
let isPlaying = false;

if (speedKnob) {
    speedKnob.value = String(highlightSpeed);
    speedValue.textContent = `${highlightSpeed} ms`;
    speedKnob.addEventListener('input', (e) => {
        const v = Number(e.target.value);
        speedValue.textContent = `${v} ms`;
        setHighlightSpeed(v);
    });
}

if (playPauseBtn) {
    playPauseBtn.addEventListener('click', () => {
        if (!isPlaying) {
            startHighlighting(Number(speedKnob.value || highlightSpeed));
            playPauseBtn.textContent = 'Pause';
            isPlaying = true;
        } else {
            stopHighlighting();
            playPauseBtn.textContent = 'Play';
            isPlaying = false;
        }
    });
}

// Avviare l'aggiornamento dei grafici ogni 60s (resta manuale l'evidenziazione)
updateCharts();
setInterval(updateCharts, 60_000);



</script>

</body>
</html>